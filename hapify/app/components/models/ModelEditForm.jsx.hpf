import React from 'react';
import PropTypes from 'prop-types';
<<? F tE+tF/hd/pr>>
import { connect } from 'react-redux';
<<?>>
import { NavLink } from 'react-router-dom';
<<= getImportLodash() >>
<<= getImportFieldComponents() >>
<<? F tF/hd/pr>>
import { InboxOutlined } from '@ant-design/icons';
<<?>>
 
import getRules from '../../utils/RulesValidator';
 
<<? F ml/tE/tF>>
import { ArrayFieldAntd } from '../elements';
 
<<?>>
<<? F tF/hd/pr>>
import { UPLOADS_URL } from '../../configs/Constants';
 
<<?>>
const <<M AA>>EditForm = ({
  onSubmit, initialValues, baseUrl,<<@ F tE/hd/pr f>> <<f.model aA>>s,<<@>>
}) => (
  <Form onFinish={(v) => onSubmit({ ...initialValues, ...v })} initialValues={initialValues}>
    <div className="grid">
      <<@ F /hd/pr/in f>>
      <<= getComponent(f) >>
 
      <<@>>
    </div>
 
    <div className="btn-group right">
      <Button type="primary" htmlType="submit">Enregistrer</Button>
 
      <NavLink to={baseUrl}>
        <Button>Annuler</Button>
      </NavLink>
    </div>
  </Form>
);
 
<<M AA>>EditForm.propTypes = {
  onSubmit: PropTypes.func.isRequired,
  initialValues: PropTypes.shape().isRequired,
  baseUrl: PropTypes.string.isRequired,
  <<? F tE/hd/pr>>
 
  <<@ F tE/hd f>>
  <<f.model aA>>s: PropTypes.objectOf(PropTypes.shape()),
  <<@>>
  <<?>>
};
 
export default <<? F tE+tF/hd/pr>>(connect(
<<? F tE>>
  (state) => ({
    <<@ F tE/hd f>>
    <<f.model aA>>s: state.data.entities.<<f.model aA>>s,
    <<@>>
  }),
<<??>>
  null,
<<?>>
)(<<M AA>>EditForm));
<<??>>(<<M AA>>EditForm);<<?>>

<<<
function hasType(type, subtype) {
    return root.fields.list.filter(
        f => !f.primary && !f.hidden && !f.internal && (f.type === type || f.subtype === type) && (!subtype || f.subtype !== subtype)
    ).length > 0;
}

function getImportLodash() {
    const imports = new Set([]);
    if (hasType('entity')) {
        imports.add('map');
    }
    
    if (imports.size === 0) return '';

    return `import { ${[...imports].join(', ')} } from 'lodash';`;
}

function getImportFieldComponents() {
    const imports = new Set(['Button', 'Form']);
    if (hasType('string')) {
        imports.add('Input');
    }
    if (hasType('number')) {
        imports.add('InputNumber');
    }
    if (hasType('boolean')) {
        imports.add('Switch');
    }
    if (hasType('datetime', 'time')) {
        imports.add('DatePicker');
    }
    if (hasType('time')) {
        imports.add('TimePicker');
    }
    if (hasType('file')) {
        imports.add('Upload');
    }
    if (hasType('entity')) {
        imports.add('Select');
    }
    
    if (imports.size === 0) return '';

    return `import {
  ${[...imports].join(', ')},
} from 'antd';`;
}

function getComponent(field) {
    const itemProps = `name="${field.names.snake}"`;
    const inputProps = `placeholder="${field.names.capital}"`;
    const customPropsTypes = {
        string: `<Form.Item ${itemProps} rules={getRules('string', ${!field.nullable})} hasFeedback>
        <Input ${inputProps} />
      </Form.Item>`,
        email: `<Form.Item ${itemProps} rules={getRules('email', ${!field.nullable})} hasFeedback>
        <Input ${inputProps} />
      </Form.Item>`,
        password: `<Form.Item ${itemProps} rules={getRules('password', ${!field.nullable})} hasFeedback>
        <Input.Password ${inputProps} />
      </Form.Item>`,
        url: `<Form.Item ${itemProps} rules={getRules('url', ${!field.nullable})} hasFeedback>
        <Input ${inputProps} />
      </Form.Item>`,
        text: `<Form.Item ${itemProps} rules={getRules('text', ${!field.nullable})} hasFeedback>
        <Input.TextArea ${inputProps} />
      </Form.Item>`,
        // rich wysiwyg
        // phone cleave

        number: `<Form.Item ${itemProps} rules={getRules('number', ${!field.nullable})} hasFeedback>
        <InputNumber ${inputProps} />
      </Form.Item>`,
        integer: `<Form.Item ${itemProps} rules={getRules('integer', ${!field.nullable})} hasFeedback>
        <InputNumber ${inputProps} step={1} />
      </Form.Item>`,
        float: `<Form.Item ${itemProps} rules={getRules('number', ${!field.nullable})} hasFeedback>
        <InputNumber ${inputProps} step={0.01} />
      </Form.Item>`,
        // lat
        // long

        boolean: `<Form.Item ${itemProps} rules={getRules('boolean', ${!field.nullable})} valuePropName="checked" hasFeedback>
        <Switch ${inputProps} />
      </Form.Item>`,

        datetime: `<Form.Item ${itemProps} rules={getRules('datetime', ${!field.nullable})} hasFeedback>
        <DatePicker ${inputProps} showTime />
      </Form.Item>`,
        date: `<Form.Item ${itemProps} rules={getRules('date', ${!field.nullable})} hasFeedback>
        <DatePicker ${inputProps} />
      </Form.Item>`,
        time: `<Form.Item ${itemProps} rules={getRules('time', ${!field.nullable})} hasFeedback>
        <TimePicker ${inputProps} />
      </Form.Item>`,

        // object ??
        
        file: `<Form.Item ${itemProps} rules={getRules('file', ${!field.nullable})} valuePropName="fileList" getValueFromEvent={() => []} hasFeedback>
        <Upload.Dragger name="files" action={UPLOADS_URL} withCredentials${field.multiple ? ' multiple' : ''}>
          <p className="ant-upload-drag-icon">
            <InboxOutlined />
          </p>
          <p className="ant-upload-text">Click or drag file to this area to upload</p>
          <p className="ant-upload-hint">Support for a single or bulk upload.</p>
        </Upload.Dragger>
      </Form.Item>`,
        // image ??
        // video ??
        // audio ??
        // document ??
        
        entity: `<Form.Item ${itemProps} rules={getRules('entity', ${!field.nullable})} hasFeedback>
        <Select ${inputProps}${field.multiple ? ' mode="multiple"' : ''}>
          {map(${field.model && field.model.names.camel}s, (${field.model && field.model.names.camel}) => (
            <Select.Option key={${field.model && field.model.names.camel}.${field.model && field.model.fields.primary.names.raw}} value={${field.model && field.model.names.camel}.${field.model && field.model.fields.primary.names.raw}}>{${field.model && field.model.names.camel}.${field.model && field.model.fields.lb[0] && field.model.fields.lb[0].names.snake}}</Select.Option>
          ))}
        </Select>
      </Form.Item>`,
    };

    const component = customPropsTypes[field.subtype] || customPropsTypes[field.type] || customPropsTypes['string'];
    if (field.multiple && field.type !== 'entity' && field.type !== 'file') {
        return `<ArrayFieldAntd ${itemProps} addLabel="Ajouter un élément" removable>
        {(field) => (
          ${component.replace(itemProps, "name={field.name} fieldKey={field.fieldKey}")}
        )}
      </ArrayFieldAntd>`
    }
    return component;
}

function getError (field, indent) {
    let errors = '';
    if (field.multiple) {
        if (!field.nullable) {
            errors += `${indent}if (!values.${field.names.snake} || values.${field.names.snake}.length === 0) errors.${field.names.snake} = { _error: 'Can\\'t be empty' };
    else {
      errors.${field.names.snake} = [];
      map(values.${field.names.snake}, (value, key) => {
        if (!value) errors.${field.names.snake}[key] = 'Can\\'t be empty';
      });
    }\n`;
        }
        errors += `${indent}if (!Array.isArray(values.${field.names.snake})) errors.${field.names.snake} = { _error: 'Must be an array' };\n`;
        return errors;
    }

    const nullable = field.nullable ? `values.${field.names.snake} && ` : '';
    const customPropsTypes = {
        email: `if (${nullable}!isEmail(values.${field.names.snake} || '')) errors.${field.names.snake} = 'Is not an email';`,
        number: `if (${nullable}!isNumber(values.${field.names.snake})) errors.${field.names.snake} = 'Is not a number';`,
        integer: `if (${nullable}!isInteger(values.${field.names.snake})) errors.${field.names.snake} = 'Is not an integer';`,
        float: `if (${nullable}!isNumber(values.${field.names.snake})) errors.${field.names.snake} = 'Is not a float';`,
        boolean: `if (${nullable}!(values.${field.names.snake} === false || values.${field.names.snake} === true)) errors.${field.names.snake} = 'Is not a boolean';`,
    };
    if (customPropsTypes[field.subtype] || customPropsTypes[field.type]) {
        errors += `${indent}${customPropsTypes[field.subtype] || customPropsTypes[field.type]}\n`;
    } else if (!field.nullable) {
        errors += `${indent}if (!values.${field.names.snake}) errors.${field.names.snake} = 'Can\\'t be empty';\n`;
    }
    
    return errors;
}
>>>
